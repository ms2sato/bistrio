# これは何ですか？

TypeScript & React & Zod 製のWebアプリケーションフレームワークです。三層アーキテクチャで言うプレゼンテーション層を責務にしていて、JSXで書かれるフロントエンドと、フロントエンドと疎通するためのバックエンドの層(サーバーの表層)をカバーしています。

## 課題と解法

Next.js、Vue.jsなどの多くのフレームワークはフロントエンドだけを関心事にしています。その場合、以下のような課題があると考えています。

- 多くの場合においてバックエンドとの接続について本質的ではない作業（URLを疎通するように調整するなど）が発生してしまう。
- Server Side Rendering(SSR)を利用しようとするとフロントエンド用のサーバー（BFF）が必要になり、システム構成が複雑化する。

このような課題に対応するため、本フレームワークは"フロントエンドからバックエンドの入り口まで"を責務としています。それにより以下のようになりました。

- サーバーのコードからフロントエンド用の通信コードを自動生成できるため、オブジェクトのメソッドとして呼び出すことで通信ができ、疎通作業が不要です。
- バックエンド部分も含んだフレームワークのためBFFが不要です。

バックエンド側はRESTの哲学に従って構築する考えのため、Resource を概念として定義し、そのメソッドを呼び出すまでがフレームワークの責務となっています。フルスタックではないので、Resourceの実装となるDBなどの構成は好きなものを選んでいただけます。

# 特徴

- SSRされるPageの内容がクライアント・サーバー間でなるべく差異を持たないように設計されています。
- JSXで書かれるPageでは、サーバーから公開されるResourceオブジェクトを呼び出すコードが書けます。Remote Procedure Call(RPC) のように、サーバーから公開されているオブジェクトの型に対してコードを書けます。
  - 実行時はそれぞれ以下のように動作します。
    - CSR: 自動生成された Resourceオブジェクトのスタブを介して APIをコールするコードとして呼び出されます。
    - SSR: Resourceオブジェクトを直接コールし、DBへの接続まで同一プロセスで行うコードとして呼び出されるため、実行効率の高い処理になります。
- RoutesやResourceのコードを書くと自動的に多くのコードを生成して、開発者が定型の退屈なコードを書かなくて良いように作られています。この時、TypeScriptの型情報で完結させており、OpenAPIのフォーマットのような外部フォーマットを別途書くようなことをしないで開発できます。詳しくは[自動生成](#自動生成)をご覧ください。

## Routes-driven development(RDD)

Webのシステムにおいて最も情報が多いのがルーティングであるため、まずこのルーティングから開発を始めることを推奨しています。この情報は複数の箇所で統一して利用されるため、システムの一貫性を維持します。

以下のような中心になる複数のRouting情報が一つのRoutes情報から生成されます。

- サーバーの Routing 情報
- ブラウザの SPA Routing の情報
- REPLで利用可能なResource情報

## Resource-View-Routes(RVR)

本フレームワークはMVCの設計ではありません。MVCは多くの人が慣れ親しんだ大変わかりやすい概念だと思います。しかし本フレームワークではあえてControllerを廃した形を取りました。

というのは Controller は "ロジックが書きたくなるようなファイルであるにも関わらずWebの情報を扱う概念" であるためです。このコンフリクトがいわゆる Fat Controller のような問題も生んでしまいます。これに抗うため 多くの人が Controller から処理を委譲されるクラスを書きたくなるなどしていたと思います。

本システムにおける Resource は、Controllerと位置付けが大変似てはいますが、"Webに関する情報を持たないもの"です。つまり広義の Model の位置付けです。このファイルにはユースケースに従った多くのロジックを書けます。もしも共通化などが必要であれば別の概念（MVCのModelに近いものになると思います）をアプリケーションの開発者が考えれば良いでしょう。

結果、多くの場合にController が担っていた以下の機能は Routes へ移動されました。

- アクセス可能かどうかの権限チェック(Middleware)
- クライアントから送信された値のチェック(Zod)
- Mass Assignment 脆弱性への対応(Zod)

### Resource

RESTの概念における Resource です。Resourceは開発者が必要とするメソッドを自由に作成できます。Routesからはこれらのメソッドをアクションとして呼び出せます。

- Modelの自動テストでテストができます。
- ResourceはREPLからも簡単に呼び出せるため、ロジックの動作確認がやりやすいです。
- 広義のModelの位置付けなので、多くのロジックをそのまま書いて問題ありません。

### View

JSXで書かれたViewです。本フレームワークでは RenderSupport を介して サーバーのResourceを操作できます。React18 から導入された Suspense への対応も済んでいるので、 useEffect を多用するコードを書く必要はありません。

### Routes

独自のDSLを使って構造化されたRoutingを定義します。この時、Zodの型情報を各アクションに対して割り当て、フレームワークが行うスキーマチェックを通過したものだけが Resource で扱えるようにしています。つまり入力値のバリデーションが自動で行われ、明示した値だけがサーバーで受信され、堅牢になります。

# 自動生成

## SPA Routingの設定とサーバーのRouting

共通のRoutesから自動生成されるため、クライアントとサーバーの複数のルーティングを一致させることを考える必要はありません。

## クライアントで利用するスタブ

RoutesとResourceの情報から自動的に作成されるため、サーバー側のコード一致するスタブ生成について意識する必要はありません。

## エンドポイントの情報

ハイパーリンク等で利用されるエンドポイントの情報が Routesから自動生成されるため、型に従って利用すればリンク切れを起こすことがありません。

# ディレクトリ構造

- .bistrio: 自動生成のコードはこの下に作成されます
- bin: コマンド
- config: 設定群（普段あまり操作しないものが入っています）
- public: Webに公開されるstaticなファイル
- server: サーバーサイドのコード
  - resources: Resource を配置するディレクトリ
- universal: サーバー・クライアントでの共通のコード
  - pages: JSXを配置するディレクトリ
  - routes: Routes を配置するディレクトリ
  - middleware.ts: routesで利用されるMiddlewareを配置するファイル